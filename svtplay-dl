#!/usr/bin/env python
import sys
if sys.version_info > (3, 0):
    from urllib.request import Request, urlopen
    from urllib.error import HTTPError, URLError
    from urllib.parse import urlparse, parse_qs, unquote_plus, quote_plus
else:
    from urllib2 import Request, urlopen, HTTPError, URLError
    from urlparse import urlparse, parse_qs
    from urllib import unquote_plus, quote_plus

import re
import os
import subprocess
from optparse import OptionParser
import xml.etree.ElementTree as ET
import shlex
import json
import time
import logging

__version__ = "0.7.2012.06.04"

def get_http_data(url, method="GET", header="", data=""):
    """ Get the page to parse it for streams """
    request = Request(url)
    request.add_header('User-Agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')

    if len(header) > 0:
        request.add_header('Content-Type', header)
    if len(data) > 0:
        request.add_data(data)
    try:
        response = urlopen(request)
    except HTTPError as e:
        logging.error("Something wrong with that url")
        logging.error("Error code: %s" % e.code)
        sys.exit(5)
    except URLError as e:
        logging.error("Something wrong with that url")
        logging.error("Error code: %s" % e.reason)
        sys.exit(5)
    except ValueError as e:
        logging.error("Try adding http:// before the url")
        sys.exit(5)
    if sys.version_info > (3, 0):
        data = response.read().decode('utf-8')
    else:
        try:
            data = response.read()
        except socket.error as e:
            logging.error("Lost the connection to the server")
            sys.exit(5)
    response.close()
    return data

def progress(byte, total):
    """ Print some info about how much we have downloaded """
    ratio = float(byte) / total
    percent = round(ratio*100, 2)
    tlen = str(len(str(total)))
    fmt = "Downloaded %"+tlen+"dkB of %dkB bytes (% 3.2f%%)"
    progresstr = fmt % (byte >> 10, total >> 10, percent)

    columns = int(os.getenv("COLUMNS", "80"))
    if len(progresstr) < columns - 13:
        p = int((columns - len(progresstr) - 3) * ratio)
        q = int((columns - len(progresstr) - 3) * (1 - ratio))
        progresstr = "[" + ("#" * p) + (" " * q) + "] " + progresstr
    sys.stderr.write(progresstr + '\r')

    if byte >= total:
        sys.stderr.write('\n')

    sys.stderr.flush()

def download_http(url, output):
    """ Get the stream from HTTP """
    response = urlopen(url)
    total_size = response.info()['Content-Length']
    total_size = int(total_size)
    bytes_so_far = 0
    if output != "-":
        extension = re.search("(\....)$", url)
        if extension:
            output = output + extension.group(1)
        file_d = open(output,"wb")
    else:
        file_d = sys.stdout

    lastprogress = 0
    while 1:
        chunk = response.read(8192)
        bytes_so_far += len(chunk)

        if not chunk:
            break

        file_d.write(chunk)
        if output != "-":
            now = time.time()
            if lastprogress + 1 < now:
                lastprogress = now
                progress(bytes_so_far, total_size)

    if output != "-":
        file_d.close()

def download_rtmp(options, url, output, live, extra_args, resume):
    """ Get the stream from RTMP """
    args = []
    if live:
        args.append("-v")

    if resume:
        args.append("-e")

    extension = re.search("(\....)$", url)
    if output != "-":
        if not extension:
            extension = re.search("-y (.+):[-_a-z0-9\/]", extra_args)
            if not extension:
                output = output + ".flv"
            else:
                output = output + "." + extension.group(1)
        else:
            output = output + extension.group(1)
        args += ["-o", output]
    if options.silent or output == "-":
        args.append("-q")
    if extra_args:
        args += shlex.split(extra_args)
    command = ["rtmpdump", "-r", url] + args
    subprocess.call(command)

def select_quality(options, streams):
    sort = sorted(streams.keys(), key=int)

    if options.quality:
        quality = options.quality
    else:
        quality = sort.pop()

    try:
        selected = streams[int(quality)]
    except KeyError:
        logging.error("Can't find that quality. (Try one of: %s)",
                      ", ".join(map(str, sort)))
        sys.exit(4)

    return selected

class Justin():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = get_http_data(url)
        data = re.sub("<(\d+)", "<_\g<1>", data)
        data = re.sub("</(\d+)", "</_\g<1>", data)
        xml = ET.XML(data)
        if sys.version_info < (2, 7):
            sa = list(xml)
        else:
            sa = list(xml)
        streams = {}
        for i in sa:
            if i.tag[1:][:-1] != "iv":
                try:
                    stream = {}
                    stream["token"] = i.find("token").text
                    stream["url"] = i.find("connect").text + "/" + i.find("play").text
                    streams[i.find("video_height").text] = stream
                except AttributeError:
                    None

        test = select_quality(self.options, streams)
        other = "-j '%s' -W %s" % (test["token"], self.resume)
        self.resume = False
        download_rtmp(self.options, test["url"], self.output, self.live, other, self.resume)

class Justin2():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = get_http_data(url)
        xml = ET.XML(data)
        url = xml.find("archive").find("video_file_url").text
        if self.output != '-':
            self.output = self.output + url[-4:]
            logging.info("Outfile: %s", self.output)
        download_http(url, self.output)

class Hbo():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        data = get_http_data(url)
        xml = ET.XML(data)
        videoid = xml.find("content")[1].find("videoId").text
        url = "http://render.cdn.hbo.com/data/content/global/videos/data/%s.xml" % videoid
        data = get_http_data(url)
        xml = ET.XML(data)
        ss = xml.find("videos")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("size"))
        else:
            sa = list(ss.iter("size"))
        streams = {}
        for i in sa:
            stream = {}
            stream["path"] = i.find("tv14").find("path").text
            streams[i.attrib["width"]] = stream

        test = select_quality(self.options, streams)

        if not self.output:
            self.output = os.path.basename(test["path"])
            logging.info("Outfile: %s", self.output)

        download_rtmp(self.options, test["path"], self.output, self.live, "", self.resume)

class Sr():
    def __init__(self, options, output, live, other, resume):
        self.options = options
        self.output = output
        self.live = live
        self.other = other
        self.resume = resume

    def get(self, url):
        url = url + self.other
        data = get_http_data(url)
        xml = ET.XML(data)
        url = xml.find("entry").find("ref").attrib["href"]

        if not self.output:
            self.output = os.path.basename(url)
            logging.info("Outfile: %s", self.output)

        download_http(url, self.output)

class Urplay():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        other = "-a ondemand"
        data = get_http_data(url)
        match = re.search('file=(.*)\&plugins', data)
        if match:
            path = "mp" + match.group(1)[-1] + ":" + match.group(1)
            other = "-a ondemand -y %s" % path

            if not self.output:
                self.output = os.path.basename(path)
                logging.info("Outfile: %s", self.output)

            download_rtmp(self.options, "rtmp://streaming.ur.se/", self.output, self.live, other, self.resume)

class Qbrick():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        data = get_http_data(url)
        xml = ET.XML(data)
        server = xml.find("head").find("meta").attrib["base"]
        streams = xml.find("body").find("switch")
        if sys.version_info < (2, 7):
            sa = list(streams.getiterator("video"))
        else:
            sa = list(streams.iter("video"))
        streams = {}
        for i in sa:
            streams[i.attrib["system-bitrate"]] = i.attrib["src"]

        path = select_quality(self.options, streams)

        if not self.output:
            self.output = os.path.basename(path)
            logging.info("Outfile: %s", self.output)

        other = "-y %s" % path
        download_rtmp(self.options, server, self.output, self.live, other, self.resume)

class Kanal5():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        data = json.loads(get_http_data(url))
        steambaseurl = data["streamBaseUrl"]
        streams = {}

        for i in data["streams"]:
            stream = {}
            stream["source"] = i["source"]
            streams[i["bitrate"]] = stream

        test = select_quality(self.options, streams)

        if not self.output:
            self.output = os.path.basename(test["source"])
            logging.info("Outfile: %s", self.output)


        filename = test["source"]
        match = re.search("^(.*):", filename)
        self.output  = "%s.%s" % (self.output, match.group(1))
        other = "-W %s -y %s " % ("http://www.kanal5play.se/flash/StandardPlayer.swf", filename)
        download_rtmp(self.options, steambaseurl, self.output, self.live, other, self.resume)

class Kanal9():
    def __init__(self, options, output, live, other, resume):
        self.options = options
        self.output = output
        self.live = live
        self.other = other
        self.resume = resume

    def get(self, url):
        try:
            from pyamf import remoting
        except ImportError:
            logging.error("You need to install pyamf to download content from kanal5 and kanal9")
            logging.info("In debian the package is called python-pyamf")
            sys.exit(2)

        player_id = 811317479001
        publisher_id = 22710239001
        const = "9f79dd85c3703b8674de883265d8c9e606360c2e"
        env = remoting.Envelope(amfVersion=3)
        env.bodies.append(("/1", remoting.Request(target="com.brightcove.player.runtime.PlayerMediaFacade.findMediaById", body=[const, player_id, self.other, publisher_id], envelope=env)))
        env = str(remoting.encode(env).read())
        url = "http://" + url + "/services/messagebroker/amf?playerKey=AQ~~,AAAABUmivxk~,SnCsFJuhbr0vfwrPJJSL03znlhz-e9bk"
        header = "application/x-amf"
        data = get_http_data(url, "POST", header, env)
        streams = {}

        for i in remoting.decode(data).bodies[0][1].body['renditions']:
            stream = {}
            stream["uri"] = i["defaultURL"]
            streams[i["encodingRate"]] = stream

        test = select_quality(self.options, streams)
        if not self.output:
            self.output = os.path.basename(test["uri"])
            logging.info("Outfile: %s", self.output)

        filename = test["uri"]
        match = re.search("(rtmp[e]{0,1}://.*)\&(.*)$", filename)
        other = "-W %s -y %s " % ("http://admin.brightcove.com/viewer/us1.25.04.01.2011-05-24182704/connection/ExternalConnection_2.swf", match.group(2))
        download_rtmp(self.options, match.group(1), self.output, self.live, other, self.resume)

class Expressen():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        other = ""
        data = get_http_data(url)
        xml = ET.XML(data)
        ss = xml.find("vurls")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("vurl"))
        else:
            sa = list(ss.iter("vurl"))
        streams = {}

        for i in sa:
            streams[i.attrib["bitrate"]] = i.text

        test = select_quality(self.options, streams)

        if not self.output:
            self.output = os.path.basename(test)
            logging.info("Outfile: %s", self.output)

        filename = test
        match = re.search("rtmp://([0-9a-z\.]+/[0-9]+/)(.*).flv", filename)

        filename = "rtmp://%s" % match.group(1)
        other = "-y %s" % match.group(2)

        download_rtmp(self.options, filename, self.output, self.live, other, self.resume)

class Aftonbladet():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url, start):
        data = get_http_data(url)
        xml = ET.XML(data)
        url = xml.find("articleElement").find("mediaElement").find("baseUrl").text
        path = xml.find("articleElement").find("mediaElement").find("media").attrib["url"]
        other = "-y %s" % path

        if start > 0:
            other = other + " -A %s" % str(start)

        if url == None:
            logging.error("Can't find any video on that page")
            sys.exit(3)

        if not self.output:
            self.output = os.path.basename(path)
            logging.info("Outfile: %s", self.output)

        if url[0:4] == "rtmp":
            download_rtmp(self.options, url, self.output, self.live, other, self.resume)
        else:
            filename = url + path
            download_http(filename, self.output)

class Viaplay():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        other = ""
        data = get_http_data(url)
        xml = ET.XML(data)
        filename = xml.find("Product").find("Videos").find("Video").find("Url").text

        if filename[:4] == "http":
            data = get_http_data(filename)
            xml = ET.XML(data)
            filename = xml.find("Url").text

        if not self.output:
            self.output = os.path.basename(filename)
            logging.info("Outfile: %s", self.output)

        other = "-W http://flvplayer.viastream.viasat.tv/play/swf/player110516.swf?rnd=1315434062"
        download_rtmp(self.options, filename, self.output, self.live, other, self.resume)

class Tv4play():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        data = get_http_data(url)
        xml = ET.XML(data)
        ss = xml.find("items")
        if sys.version_info < (2, 7):
            sa = list(ss.getiterator("item"))
        else:
            sa = list(ss.iter("item"))
        streams = {}
        sa.pop(len(sa)-1)

        for i in sa:
            stream = {}
            stream["uri"] = i.find("base").text
            stream["path"] = i.find("url").text
            streams[i.find("bitrate").text] = stream

        test = select_quality(self.options, streams)

        other = "-W http://www.tv4play.se/flash/tv4playflashlets.swf -y %s" % test["path"]

        if not self.output:
            self.output = os.path.basename(test["path"])
            logging.info("Outfile: %s", self.output)

        download_rtmp(self.options, test["uri"], self.output, self.live, other, self.resume)

class Svtplay():
    def __init__(self, options, output, live, resume):
        self.options = options
        self.output = output
        self.live = live
        self.resume = resume

    def get(self, url):
        url = url + "?type=embed&output=json"
        data = json.loads(get_http_data(url))
        self.live = data["video"]["live"]
        streams = {}

        for i in data["video"]["videoReferences"]:
            if i["playerType"] == "flash":
                stream = {}
                stream["url"] = i["url"]
                streams[i["bitrate"]] = stream

        test = select_quality(self.options, streams)
        if test["url"][0:4] == "rtmp":
            download_rtmp(self.options, test["url"], self.output, self.live, "", self.resume)
        else:
            download_http(test["url"], self.output)

def main():
    """ Main program """
    usage = "usage: %prog [options] url"
    parser = OptionParser(usage=usage, version=__version__)
    parser.add_option("-o", "--output",
        metavar="OUTPUT", help="Outputs to the given filename.")
    parser.add_option("-r", "--resume",
        action="store_true", dest="resume", default=False,
        help="Resume a download")
    parser.add_option("-l", "--live",
        action="store_true", dest="live", default=False,
        help="Enable for live streams")
    parser.add_option("-s", "--silent",
        action="store_true", dest="silent", default=False)
    parser.add_option("-q", "--quality",
        metavar="quality", help="Choose what format to download.\nIt will download the best format by default")
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    output = options.output
    live = options.live
    resume = options.resume
    silent = options.silent
    if silent:
        logging.basicConfig(format='%(levelname)s %(message)s', level=logging.WARNING, stream=sys.stderr)
    else:
        logging.basicConfig(format='%(levelname)s %(message)s', level=logging.INFO, stream=sys.stdout)

    url = args[0]
    if not output:
        data = get_http_data(url)
        match = re.search("(?i)<title>\s*(.*?)\s*</title>", data)
        if match:
            if sys.version_info > (3, 0):
                title = re.sub('[^\w\s-]', '', match.group(1)).strip().lower()
                output = re.sub('[-\s]+', '-', title)
            else:
                title = unicode(re.sub('[^\w\s-]', '', match.group(1)).strip().lower())
                output = unicode(re.sub('[-\s]+', '-', title))

    if re.findall("(twitch|justin).tv", url):
        parse = urlparse(url)
        match = re.search("/b/(\d+)", parse.path)
        if match:
            url = "http://api.justin.tv/api/broadcast/by_archive/%s.xml?onsite=true" % match.group(1)
            justin = Justin2(options, output, live, resume)
            justin.get(url)
        else:
            match = re.search("/(.*)", parse.path)
            if match:
                user = match.group(1)
                data = get_http_data(url)
                match = re.search("embedSWF\(\"(.*)\", \"live", data)
                if not match:
                    logging.error("Can't find swf file.")
                other = match.group(1)
                url = "http://usher.justin.tv/find/%s.xml?type=any&p=2321" % user
                live = True
                justin = Justin(options, output, live, other)
                justin.get(url)

    if re.findall("hbo.com", url):
        parse = urlparse(url)
        try:
            other = parse[5]
        except KeyError:
            logging.error("Something wrong with that url")
            sys.exit(2)
        match = re.search("^/(.*).html", other)
        if not match:
            logging.error("Cant find video file")
            sys.exit(2)
        url = "http://www.hbo.com/data/content/" + match.group(1) + ".xml"
        hbo = Hbo(options, output, live, resume)
        hbo.get(url)

    if re.findall("tv4play", url):
        parse = urlparse(url)
        try:
            vid = parse_qs(parse[4])["videoid"][0]
        except KeyError:
            logging.error("Can't find video file")
            sys.exit(2)
        url = "http://premium.tv4play.se/api/web/asset/%s/play" % vid
        tv4play = Tv4play(options, output, live, resume)
        tv4play.get(url)

    elif re.findall("(tv3play|tv6play|tv8play)", url):
        parse = urlparse(url)
        match = re.search('\/play\/(.*)/', parse.path)
        if not match:
            logging.error("Cant find video file")
            sys.exit(2)
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(options, output, live, resume)
        viaplay.get(url)

    elif re.findall("viaplay", url):
        parse = urlparse(url)
        match = re.search('\/Tv/channels\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/[a-zA-Z0-9-]+\/(.*)/', parse.path)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        url = "http://viasat.web.entriq.net/nw/article/view/%s/?tf=players/TV6.tpl" % match.group(1)
        data = get_http_data(url)
        match = re.search("id:'(.*)'", data)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        url = "http://viastream.viasat.tv/PlayProduct/%s" % match.group(1)
        viaplay = Viaplay(options, output, live, resume)
        viaplay.get(url)

    elif re.findall("aftonbladet", url):
        parse = urlparse(url)
        data = get_http_data(url)
        match = re.search("abTvArticlePlayer-player-(.*)-[0-9]+-[0-9]+-clickOverlay", data)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        try:
            start = parse_qs(parse[4])["start"][0]
        except KeyError:
            start = 0
        url = "http://www.aftonbladet.se/resource/webbtv/article/%s/player" % match.group(1)
        aftonbladet = Aftonbladet(options, output, live, resume)
        aftonbladet.get(url, start)

    elif re.findall("expressen", url):
        parse = urlparse(url)
        match = re.search("/(.*[\/\+].*)/", unquote_plus(parse.path))
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        url = "http://tv.expressen.se/%s/?standAlone=true&output=xml" % quote_plus(match.group(1))
        expressen = Expressen(options, output, live, resume)
        expressen.get(url)

    elif re.findall("kanal5play", url):
        match = re.search(".*video/([0-9]+)", url)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        url = "http://www.kanal5play.se/api/getVideo?format=FLASH&videoId=%s" % match.group(1)
        kanal5 = Kanal5(options, output, live, resume)
        kanal5.get(url)


    elif re.findall("kanal9play", url):
        data = get_http_data(url)
        match = re.search("@videoPlayer\" value=\"(.*)\"", data)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        kanal9 = Kanal9(options, output, live, match.group(1), resume)
        kanal9.get("c.brightcove.com")

    elif re.findall("dn.se", url):
        data = get_http_data(url)
        match = re.search("data-qbrick-mcid=\"([0-9A-F]+)\"", data)
        if not match:
            match = re.search("mediaId = \'([0-9A-F]+)\';", data)
            if not match:
                logging.error("Can't find video file")
                sys.exit(2)
            mcid = match.group(1) + "DE1BA107"
        else:
            mcid = match.group(1)
        qbrick = Qbrick(options, output, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getsingleplayer/" + mcid
        data = get_http_data(host)
        xml = ET.XML(data)
        try:
            url = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            logging.error("Can't find video file")
            sys.exit(2)
        qbrick.get(url)

    elif re.findall("di.se", url):
        data = get_http_data(url)
        match = re.search("ccid: \"(.*)\"\,", data)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)
        qbrick = Qbrick(options, output, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getplayer/" + match.group(1)
        data = get_http_data(host)
        xml = ET.XML(data)
        try:
            host = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            logging.error("Can't find stream")
            sys.exit(2)
        qbrick.get(host)

    elif re.findall("svd.se", url):
        match = re.search("_([0-9]+)\.svd", url)
        if not match:
            logging.error("Can't find video file")
            sys.exit(2)

        data = get_http_data("http://www.svd.se/?service=ajax&type=webTvClip&articleId=" + match.group(1))
        match = re.search("mcid=([A-F0-9]+)\&width=", data)

        if not match:
            logging.error("Can't find video file")
            sys.exit(2)

        qbrick = Qbrick(options, output, live, resume)
        host = "http://vms.api.qbrick.com/rest/v3/getsingleplayer/" + match.group(1)
        data = get_http_data(host)
        xml = ET.XML(data)
        try:
            host = xml.find("media").find("item").find("playlist").find("stream").find("format").find("substream").text
        except AttributeError:
            logging.error("Can't find video file")
            sys.exit(2)
        qbrick.get(host)

    elif re.findall("urplay.se", url):
        urplay = Urplay(options, output, live, resume)
        urplay.get(url)

    elif re.findall("sverigesradio", url):
        data = get_http_data(url)
        parse = urlparse(url)
        try:
            metafile = parse_qs(parse[4])["metafile"][0]
            other = "%s?%s" % (parse[2], parse[4])
        except KeyError:
            match = re.search("linkUrl=(.*)\;isButton=", data)
            if not match:
                logging.error("Can't find video file")
                sys.exit(2)
            other = unquote_plus(match.group(1))
        sr = Sr(options, output, live, other, resume)
        sr.get("http://sverigesradio.se")

    elif re.findall("beta.svtplay.se", url):
        svtplay = Svtplay(options, output, live, resume)
        svtplay.get(url)

    else:
        svtplay = Svtplay(options, output, live, resume)
        svtplay.get(url)


if __name__ == "__main__":
    main()
